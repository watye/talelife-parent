序列化与反序列化

1.自定义序列化与反序列化
2.版本uid(自动生产时根据属性等复杂的算法)
3.序列化并不保存静态变量
4.父类没实现序列化接口不会序列化
5.同一个对象写多次是同一个对象的引用
6.序列化三种方式（Serializable默认序列化，Externalizable选择性序列化,Serializable自定义序列化）
7.序列化变通方式（json）,缺点是字节数过多，依赖于不同的第三方类库
8.使用Serializable方式序列化的方式下，反序列化时不会调用该对象的构造器，但是会调用父类的构造器，如果父类没有默认构造器则会报错，如果父类也实现序列化，则父类也不会调用构造器
9.使用Externalizable方式序列化的方式下,反序列化时，首先会调用对象的默认构造器（没有则报错，如果默认构造器不是public的也会报错），然后再调用readExternal方法
10.每个枚举类型都会默认继承类java.lang.Enum，而该类实现了Serializable接口，所以枚举类型对象都是默认可以被序列化的
11.使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化
12.Singleton模式时使用readResolve()方法，无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象

13.子类序列化时：
如果父类没有实现Serializable接口，没有提供默认构造函数，那么子类的序列化会出错；
如果父类没有实现Serializable接口，提供了默认的构造函数，那么子类可以序列化，父类的成员变量不会被序列化。
如果父类实现了Serializable接口，则父类和子类都可以序列化。